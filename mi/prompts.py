from __future__ import annotations

import json
from typing import Any


def _to_json(obj: Any) -> str:
    return json.dumps(obj, indent=2, sort_keys=True)


def compile_mindspec_prompt(*, values_text: str, base_template: dict[str, Any]) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Compile user values/preferences into a structured MindSpec (V1).",
            "",
            "Hard constraints (must respect in your decision procedure):",
            "- MI sits above Codex and only controls input + reads output.",
            "- MI does NOT intercept or gate Codex tool execution.",
            "- MI does NOT force Codex into step-by-step protocols.",
            "- Refactor intent is behavior-preserving by default unless explicitly requested otherwise.",
            "- If a project has no tests, MI asks once per project for a testless verification strategy, then remembers it.",
            "- MI does not ask for 'completion confirmation' by default; MI self-evaluates done/blocked.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no code fences, no extra keys, no extra commentary.",
            "- Keep values_summary short (5-12 bullets).",
            "- decision_procedure.mermaid MUST be a valid Mermaid flowchart (flowchart TD ...).",
            "",
            "User values/preferences text (verbatim):",
            values_text.strip(),
            "",
            "Base template (fill and adjust as needed; keep unspecified parts at defaults):",
            _to_json(base_template),
            "",
            "Now output the compiled MindSpec JSON.",
        ]
    ).strip() + "\n"


def extract_evidence_prompt(
    *,
    task: str,
    light_injection: str,
    batch_input: str,
    codex_batch_summary: dict[str, Any],
    repo_observation: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Extract durable evidence from a Codex batch run.",
            "",
            "Rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Be concise: keep strings short and factual.",
            "",
            "MI light injection (what Codex was told):",
            light_injection.strip(),
            "",
            "Batch input sent to Codex (verbatim):",
            (batch_input or "").strip(),
            "",
            "User task:",
            task.strip(),
            "",
            "Codex batch summary (machine extracted):",
            _to_json(codex_batch_summary),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
        ]
    ).strip() + "\n"


def decide_next_prompt(
    *,
    task: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    auto_answer: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Codex.",
            "Decide what to do next after a Codex batch, minimizing user burden.",
            "",
            "Constraints:",
            "- Do NOT ask the user to 'confirm completion' as a default. MI self-evaluates done/blocked.",
            "- Ask the user ONLY when MI cannot proceed safely due to missing information or value conflicts.",
            "- If the project has no tests and verification is needed, ask the user ONCE per project for a testless verification strategy, then remember it (ProjectOverlay).",
            "- Prefer sending a next instruction to Codex over asking the user, when values/evidence allow.",
            "- If a minimal check plan is provided and should_run_checks=true, prefer sending codex_check_input to Codex before further work, unless user input is required first.",
            "- If needs_testless_strategy=true and ProjectOverlay.testless_verification_strategy.chosen_once=false, ask the user using testless_strategy_question.",
            "- If an auto-answer suggestion is provided and should_answer=true, prefer sending codex_answer_input to Codex (possibly combined with codex_check_input) instead of asking the user.",
            "- If auto_answer.needs_user_input=true, prefer asking the user using auto_answer.ask_user_question, unless you can safely answer from values/evidence already available (then send_to_codex).",
            "",
            "Output:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "User task:",
            task.strip(),
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Auto-answer suggestion (from auto_answer_to_codex):",
            _to_json(auto_answer),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Codex last message (raw):",
            codex_last_message.strip(),
            "",
            "Now decide the next action.",
        ]
    ).strip() + "\n"


def risk_judge_prompt(
    *,
    task: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    risk_signals: list[str],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Assess risk for a Codex batch using user values/preferences and evidence.",
            "",
            "Rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If information is insufficient, set severity to 'medium' and should_ask_user=true.",
            "",
            "User task:",
            task.strip(),
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Detected risk signals (heuristic, may be empty):",
            _to_json(risk_signals),
            "",
            "Codex last message (raw):",
            codex_last_message.strip(),
            "",
            "Now output the risk judgement.",
        ]
    ).strip() + "\n"


def plan_min_checks_prompt(
    *,
    task: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    repo_observation: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Plan minimal, high-information verification checks to reduce uncertainty.",
            "",
            "Constraints:",
            "- MI does NOT run checks directly; Codex should execute checks when instructed.",
            "- Prefer existing project checks (tests/build/lint/typecheck) over introducing new tooling.",
            "- You may suggest generating a minimal smoke test only when it is low-cost and aligned with values.",
            "- If the project has no tests and verification is needed, ask the user ONCE per project for a testless verification strategy, then remember it (ProjectOverlay).",
            "- Do NOT ask the user to confirm completion; only ask when blocked by missing info.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If no checks are needed, set should_run_checks=false and codex_check_input=\"\".",
            "",
            "User task:",
            task.strip(),
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Now plan the minimal checks and produce a Codex instruction if needed.",
        ]
    ).strip() + "\n"


def auto_answer_to_codex_prompt(
    *,
    task: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Codex.",
            "Your job: answer Codex's question(s) as the user when possible, using values/preferences + evidence + memory, to minimize user burden.",
            "",
            "Constraints:",
            "- MI sits above Codex and only controls input + reads output.",
            "- MI does NOT intercept or gate Codex tool execution.",
            "- MI does NOT force Codex into step-by-step protocols.",
            "- Do NOT ask the user to confirm completion; only ask when blocked by missing info or value conflicts.",
            "- MI is authorized to answer on behalf of the user (including when the user task says 'ask the user') using values/preferences and evidence.",
            "- If Codex asks for permission to do external actions (network/install/push/publish), decide using values/preferences; if not clearly covered, set needs_user_input=true.",
            "- If values/preferences clearly imply the answer (e.g., default-deny for network/install unless necessary), answer Codex directly without asking the user, unless evidence shows it is necessary and allowed.",
            "- If Codex asks what it should do next (e.g., 'what would you like me to do'), answer by restating the user task and any relevant constraints; do NOT ask the user.",
            "- If the last Codex message does not contain a question or request for user input, set should_answer=false and codex_answer_input=\"\".",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Keep codex_answer_input concise and directly actionable; only include what Codex needs to proceed.",
            "",
            "User task:",
            task.strip(),
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Codex last message (raw):",
            codex_last_message.strip(),
            "",
            "Now decide whether MI can answer Codex, and output the JSON.",
        ]
    ).strip() + "\n"


def closure_eval_prompt(
    *,
    task: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    auto_answer: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Codex.",
            "Evaluate whether the task is complete (closed loop), using values/preferences and evidence.",
            "",
            "Constraints:",
            "- Do NOT ask the user to confirm completion by default; MI self-evaluates done/blocked.",
            "- If the task is done, set status=done and explain briefly via done_reasons/notes.",
            "- If more work is needed, set status=not_done and list blocking_issues.",
            "- Set status=blocked ONLY if MI cannot proceed without user input; then set ask_user_question (otherwise leave it empty).",
            "- Consider the minimal check plan: if verification is required and checks were not run, status should usually be not_done (not done).",
            "- MI is authorized to answer on behalf of the user (including when the task says 'ask the user') using values/preferences and evidence; do NOT treat this as blocked if the answer is clear.",
            "- If Codex asked a permission question and MI already provided (or can provide) an answer via auto_answer_to_codex, treat that as the user answer for closure purposes.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "User task:",
            task.strip(),
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Auto-answer suggestion (from auto_answer_to_codex):",
            _to_json(auto_answer),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Codex last message (raw):",
            codex_last_message.strip(),
            "",
            "Now output the closure evaluation JSON.",
        ]
    ).strip() + "\n"
