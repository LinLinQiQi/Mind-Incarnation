from __future__ import annotations

import json
from typing import Any


def _to_json(obj: Any) -> str:
    return json.dumps(obj, indent=2, sort_keys=True)


def compile_mindspec_prompt(*, values_text: str, base_template: dict[str, Any]) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Compile user values/preferences into a structured MindSpec (V1).",
            "",
            "Hard constraints (must respect in your decision procedure):",
            "- MI sits above Hands (execution agent; V1 default: Codex CLI) and only controls input + reads output.",
            "- MI does NOT intercept or gate Hands tool execution.",
            "- MI does NOT force Hands into step-by-step protocols.",
            "- Refactor intent is behavior-preserving by default unless explicitly requested otherwise.",
            "- If a project has no tests, MI asks once per project for a testless verification strategy, then remembers it.",
            "- MI does not ask for 'completion confirmation' by default; MI self-evaluates done/blocked.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no code fences, no extra keys, no extra commentary.",
            "- Keep values_summary short (5-12 bullets).",
            "- decision_procedure.mermaid MUST be a valid Mermaid flowchart (flowchart TD ...).",
            "",
            "User values/preferences text (verbatim):",
            values_text.strip(),
            "",
            "Base template (fill and adjust as needed; keep unspecified parts at defaults):",
            _to_json(base_template),
            "",
            "Now output the compiled MindSpec JSON.",
        ]
    ).strip() + "\n"


def extract_evidence_prompt(
    *,
    task: str,
    hands_provider: str,
    light_injection: str,
    batch_input: str,
    codex_batch_summary: dict[str, Any],
    repo_observation: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Extract durable evidence from a Hands batch run.",
            "",
            "Rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Be concise: keep strings short and factual.",
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MI light injection (what Hands was told):",
            light_injection.strip(),
            "",
            "Batch input sent to Hands (verbatim):",
            (batch_input or "").strip(),
            "",
            "User task:",
            task.strip(),
            "",
            "Hands batch summary (machine extracted):",
            _to_json(codex_batch_summary),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
        ]
    ).strip() + "\n"


def decide_next_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    active_workflow: dict[str, Any] | None = None,
    workflow_run: dict[str, Any] | None = None,
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    auto_answer: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Hands.",
            "Decide what to do next after a Hands batch, minimizing user burden.",
            "",
            "Constraints:",
            "- This prompt also serves as MI's 'closure' evaluation: if the task is complete, stop.",
            "- Only set status=done when confidence >= 0.6; otherwise keep working or run checks.",
            "- If status=done: set next_action=stop.",
            "- If status=blocked: set next_action=ask_user and provide ask_user_question.",
            "- Do NOT ask the user to 'confirm completion' as a default. MI self-evaluates done/blocked.",
            "- Ask the user ONLY when MI cannot proceed safely due to missing information or value conflicts.",
            "- If the project has no tests and verification is needed, ask the user ONCE per project for a testless verification strategy, then remember it (ProjectOverlay).",
            "- Prefer sending a next instruction to Hands over asking the user, when values/evidence allow.",
            "- If a minimal check plan is provided and should_run_checks=true, prefer sending codex_check_input to Hands before further work, unless user input is required first.",
            "- If needs_testless_strategy=true and ProjectOverlay.testless_verification_strategy.chosen_once=false, ask the user using testless_strategy_question.",
            "- If an auto-answer suggestion is provided and should_answer=true, prefer sending codex_answer_input to Hands (possibly combined with codex_check_input) instead of asking the user.",
            "- If auto_answer.needs_user_input=true, prefer asking the user using auto_answer.ask_user_question, unless you can safely answer from values/evidence already available (then send_to_codex).",
            "- If check_plan.should_run_checks=false but verification seems necessary, you may still propose a small set of checks via next_codex_input.",
            "",
            "Output:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Active workflow (if any; MI IR):",
            _to_json(active_workflow if isinstance(active_workflow, dict) else {}),
            "",
            "Workflow run state (best-effort cursor; if any):",
            _to_json(workflow_run if isinstance(workflow_run, dict) else {}),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Auto-answer suggestion (from auto_answer_to_codex):",
            _to_json(auto_answer),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Hands last message (raw):",
            codex_last_message.strip(),
            "",
            "Now decide the next action.",
        ]
    ).strip() + "\n"


def risk_judge_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    risk_signals: list[str],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Assess risk for a Hands batch using user values/preferences and evidence.",
            "",
            "Rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If information is insufficient, set severity to 'medium' and should_ask_user=true.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Detected risk signals (heuristic, may be empty):",
            _to_json(risk_signals),
            "",
            "Hands last message (raw):",
            codex_last_message.strip(),
            "",
            "Now output the risk judgement.",
        ]
    ).strip() + "\n"


def plan_min_checks_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    repo_observation: dict[str, Any],
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Plan minimal, high-information verification checks to reduce uncertainty.",
            "",
            "Constraints:",
            "- MI does NOT run checks directly; Hands should execute checks when instructed.",
            "- Prefer existing project checks (tests/build/lint/typecheck) over introducing new tooling.",
            "- You may suggest generating a minimal smoke test only when it is low-cost and aligned with values.",
            "- If the project has no tests and verification is needed, ask the user ONCE per project for a testless verification strategy, then remember it (ProjectOverlay).",
            "- Do NOT ask the user to confirm completion; only ask when blocked by missing info.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If no checks are needed, set should_run_checks=false and codex_check_input=\"\".",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Now plan the minimal checks and produce a Hands instruction if needed.",
        ]
    ).strip() + "\n"


def workflow_progress_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    workflow: dict[str, Any],
    workflow_run: dict[str, Any],
    latest_evidence: dict[str, Any],
    last_batch_input: str,
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Infer workflow step progress from evidence, without enforcing step-by-step reporting.",
            "",
            "Goal:",
            "- Update MI's internal workflow cursor (best-effort): which steps are completed, and what the next step is.",
            "",
            "Constraints:",
            "- Do NOT ask the user questions.",
            "- Do NOT require Hands to follow a rigid protocol; Hands may complete multiple steps in one batch.",
            "- Only mark a step complete when evidence strongly implies it was completed.",
            "- You may mark multiple steps complete at once if Hands likely crossed them.",
            "- If you are uncertain, set should_update=false and keep next_step_id empty.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- completed_step_ids MUST be step ids from the provided workflow.steps list.",
            "- next_step_id MUST be a step id from the workflow.steps list, or empty when unknown/none.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay (may include prior workflow_run state):",
            _to_json(project_overlay),
            "",
            "Active workflow (MI IR):",
            _to_json(workflow),
            "",
            "Current workflow_run state (prior):",
            _to_json(workflow_run),
            "",
            "Latest evidence (from extract_evidence):",
            _to_json(latest_evidence),
            "",
            "Last batch input MI sent to Hands (verbatim):",
            (last_batch_input or "").strip(),
            "",
            "Hands last message (raw):",
            (codex_last_message or "").strip(),
            "",
            "Now output the workflow progress JSON.",
        ]
    ).strip() + "\n"


def checkpoint_decide_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    segment_evidence: list[dict[str, Any]],
    current_batch_id: str,
    planned_next_input: str,
    status_hint: str,
    notes: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Decide whether to cut a 'segment checkpoint' after the current batch, and whether to mine workflows/preferences now.",
            "",
            "Definitions:",
            "- A segment is a coherent, potentially-repeatable chunk of work within a longer task.",
            "- A checkpoint is a boundary where it is safe/useful to summarize, mine a workflow, and reset the segment buffer.",
            "",
            "Constraints:",
            "- Prefer low user burden: do NOT introduce more user questions.",
            "- Do NOT enforce protocol tyranny; do not require rigid step-by-step reporting.",
            "- Only checkpoint when there is strong signal of subtask completion, phase change, or a clear boundary.",
            "- If the task is still in the middle of a single coherent flow, do NOT checkpoint.",
            "- If planned_next_input starts a new phase (e.g., 'now run tests', 'now refactor', 'now write docs'), consider checkpointing.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If should_checkpoint=false, set checkpoint_kind=none and set should_mine_workflow/should_mine_preferences=false.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Segment evidence so far (most recent last):",
            _to_json(segment_evidence),
            "",
            f"Current batch_id: {current_batch_id}",
            f"Status hint: {status_hint}",
            "",
            "Planned next input to Hands (may be empty if stopping):",
            planned_next_input.strip(),
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output the checkpoint decision JSON.",
        ]
    ).strip() + "\n"


def suggest_workflow_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    notes: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Suggest a reusable workflow IR only when it would significantly reduce user burden in future runs.",
            "",
            "Constraints:",
            "- MI sits above Hands and only controls input + reads output.",
            "- Do NOT enforce step-by-step protocol tyranny. Workflow steps should be coarse-grained and goal-oriented.",
            "- Only suggest a workflow when it is likely to repeat (or the benefit is extremely high).",
            "- Prefer project-scoped workflow suggestions by default (V1 solidification writes to the project store).",
            "- The workflow IR will be stored as MI source-of-truth; host workspace files are derived artifacts.",
            "- If you are not confident, set should_suggest=false and suggestion=null.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "If you suggest a workflow:",
            "- Provide a stable signature string (used to count occurrences across runs).",
            "- Provide benefit=high ONLY when the user-burden reduction is substantial.",
            "- Provide a small number of steps (3-7). Each step MUST have an id.",
            "- Set workflow.enabled=false in the suggestion; MI decides whether to auto-enable.",
            "- Set workflow.id to an empty string.",
            "",
            "Now output the JSON.",
        ]
    ).strip() + "\n"


def mine_preferences_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    notes: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Mine likely-stable user preferences/habits from MI-captured transcript/evidence, and suggest reversible learned rules.",
            "",
            "Constraints:",
            "- Use ONLY the provided task + evidence (derived from MI-captured transcript) and any explicit user statements inside it.",
            "- Do NOT invent preferences. If unclear, suggest nothing.",
            "- Prefer project-scoped suggestions unless the preference is clearly global.",
            "- Keep suggestions low-burden: avoid rules that would cause MI to ask the user more often.",
            "- Do NOT enforce protocol tyranny; do not suggest rigid step-by-step reporting requirements.",
            "- Suggest at most a few high-signal learned rules; each should be actionable and unambiguous.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Keep text short; write learned rules as imperative guidance (one sentence).",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Existing learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output preference suggestions (or an empty list).",
        ]
    ).strip() + "\n"


def edit_workflow_prompt(
    *,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    workflow: dict[str, Any],
    user_request: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Edit a stored workflow IR based on the user's natural-language request.",
            "",
            "Constraints:",
            "- Preserve workflow.id, workflow.version, and workflow.created_ts.",
            "- Make the smallest change that satisfies the request.",
            "- Keep step ids stable when possible; only add/remove steps when necessary.",
            "- Ensure every step has all required fields, even if empty strings.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Current workflow JSON:",
            _to_json(workflow),
            "",
            "User request:",
            (user_request or "").strip(),
            "",
            "Now output the edited workflow JSON + change_summary + conflicts + notes.",
        ]
    ).strip() + "\n"


def auto_answer_to_codex_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Hands.",
            "Your job: answer Hands' question(s) as the user when possible, using values/preferences + evidence + memory, to minimize user burden.",
            "",
            "Constraints:",
            "- MI sits above Hands and only controls input + reads output.",
            "- MI does NOT intercept or gate Hands tool execution.",
            "- MI does NOT force Hands into step-by-step protocols.",
            "- Do NOT ask the user to confirm completion; only ask when blocked by missing info or value conflicts.",
            "- MI is authorized to answer on behalf of the user (including when the user task says 'ask the user') using values/preferences and evidence.",
            "- If Hands asks for permission to do external actions (network/install/push/publish), decide using values/preferences; if not clearly covered, set needs_user_input=true.",
            "- If values/preferences clearly imply the answer (e.g., default-deny for network/install unless necessary), answer Hands directly without asking the user, unless evidence shows it is necessary and allowed.",
            "- If Hands asks what it should do next (e.g., 'what would you like me to do'), answer by restating the user task and any relevant constraints; do NOT ask the user.",
            "- If the last Hands message does not contain a question or request for user input, set should_answer=false and codex_answer_input=\"\".",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Keep codex_answer_input concise and directly actionable; only include what Hands needs to proceed.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Hands last message (raw):",
            codex_last_message.strip(),
            "",
            "Now decide whether MI can answer Hands, and output the JSON.",
        ]
    ).strip() + "\n"


def closure_eval_prompt(
    *,
    task: str,
    hands_provider: str,
    mindspec_base: dict[str, Any],
    learned_text: str,
    project_overlay: dict[str, Any],
    repo_observation: dict[str, Any],
    check_plan: dict[str, Any],
    auto_answer: dict[str, Any],
    recent_evidence: list[dict[str, Any]],
    codex_last_message: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation), operating above Hands.",
            "Evaluate whether the task is complete (closed loop), using values/preferences and evidence.",
            "",
            "Constraints:",
            "- Do NOT ask the user to confirm completion by default; MI self-evaluates done/blocked.",
            "- If the task is done, set status=done and explain briefly via done_reasons/notes.",
            "- If more work is needed, set status=not_done and list blocking_issues.",
            "- Set status=blocked ONLY if MI cannot proceed without user input; then set ask_user_question (otherwise leave it empty).",
            "- Consider the minimal check plan: if verification is required and checks were not run, status should usually be not_done (not done).",
            "- MI is authorized to answer on behalf of the user (including when the task says 'ask the user') using values/preferences and evidence; do NOT treat this as blocked if the answer is clear.",
            "- If Hands asked a permission question and MI already provided (or can provide) an answer via auto_answer_to_codex, treat that as the user answer for closure purposes.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "MindSpec base (structured):",
            _to_json(mindspec_base),
            "",
            "Learned preferences (reversible text):",
            learned_text.strip() or "(none)",
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Repo observation (read-only heuristic):",
            _to_json(repo_observation),
            "",
            "Minimal check plan (from plan_min_checks):",
            _to_json(check_plan),
            "",
            "Auto-answer suggestion (from auto_answer_to_codex):",
            _to_json(auto_answer),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Hands last message (raw):",
            codex_last_message.strip(),
            "",
            "Now output the closure evaluation JSON.",
        ]
    ).strip() + "\n"
