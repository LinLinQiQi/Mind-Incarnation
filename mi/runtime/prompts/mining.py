from __future__ import annotations

from typing import Any

from ._util import _to_json


def checkpoint_decide_prompt(
    *,
    task: str,
    hands_provider: str,
    runtime_cfg: dict[str, Any],
    project_overlay: dict[str, Any],
    thought_db_context: dict[str, Any] | None,
    segment_evidence: list[dict[str, Any]],
    current_batch_id: str,
    planned_next_input: str,
    status_hint: str,
    notes: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Decide whether to cut a 'segment checkpoint' after the current batch, and whether to mine workflows/preferences now.",
            "",
            "Definitions:",
            "- A segment is a coherent, potentially-repeatable chunk of work within a longer task.",
            "- A checkpoint is a boundary where it is safe/useful to summarize, mine a workflow, and reset the segment buffer.",
            "",
            "Constraints:",
            "- Prefer low user burden: do NOT introduce more user questions.",
            "- Do NOT enforce protocol tyranny; do not require rigid step-by-step reporting.",
            "- Only checkpoint when there is strong signal of subtask completion, phase change, or a clear boundary.",
            "- If the task is still in the middle of a single coherent flow, do NOT checkpoint.",
            "- If planned_next_input starts a new phase (e.g., 'now run tests', 'now refactor', 'now write docs'), consider checkpointing.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If should_checkpoint=false, set checkpoint_kind=none and set should_mine_workflow/should_mine_preferences=false.",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "Runtime config (structured):",
            _to_json(runtime_cfg),
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Thought DB context (canonical values/preferences; may be empty):",
            _to_json(thought_db_context if isinstance(thought_db_context, dict) else {}),
            "",
            "Segment evidence so far (most recent last):",
            _to_json(segment_evidence),
            "",
            f"Current batch_id: {current_batch_id}",
            f"Status hint: {status_hint}",
            "",
            "Planned next input to Hands (may be empty if stopping):",
            planned_next_input.strip(),
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output the checkpoint decision JSON.",
        ]
    ).strip() + "\n"


def mine_preferences_prompt(
    *,
    task: str,
    hands_provider: str,
    runtime_cfg: dict[str, Any],
    project_overlay: dict[str, Any],
    thought_db_context: dict[str, Any] | None,
    recent_evidence: list[dict[str, Any]],
    notes: str,
) -> str:
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Mine likely-stable user preferences/habits from MI-captured transcript/evidence.",
            "Output suggestions that MI can store as Thought DB preference/goal Claims (canonical), so future decisions do not depend on free-form learned text.",
            "",
            "Constraints:",
            "- Use ONLY the provided task + evidence (derived from MI-captured transcript/evidence) and any explicit user statements inside it.",
            "- Do NOT invent preferences. If unclear, suggest nothing.",
            "- Prefer project-scoped suggestions unless the preference is clearly global.",
            "- Keep suggestions low-burden: avoid rules that would cause MI to ask the user more often.",
            "- Do NOT enforce protocol tyranny; do not suggest rigid step-by-step reporting requirements.",
            "- Suggest at most a few high-signal preferences/goals; each should be actionable and unambiguous.",
            "- Avoid duplicating existing preference/goal Claims already present in the provided Thought DB context.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- Keep text short; write preference/goal guidance as imperative guidance (one sentence).",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "Runtime config (structured):",
            _to_json(runtime_cfg),
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Thought DB context (canonical values/preferences; may be empty):",
            _to_json(thought_db_context if isinstance(thought_db_context, dict) else {}),
            "",
            "Recent evidence (most recent last):",
            _to_json(recent_evidence),
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output preference suggestions (or an empty list).",
        ]
    ).strip() + "\n"


def mine_claims_prompt(
    *,
    task: str,
    hands_provider: str,
    runtime_cfg: dict[str, Any],
    project_overlay: dict[str, Any],
    thought_db_context: dict[str, Any] | None,
    segment_evidence: list[dict[str, Any]],
    allowed_event_ids: list[str],
    min_confidence: float,
    max_claims: int,
    notes: str,
) -> str:
    allowed = [str(x) for x in allowed_event_ids if str(x).strip()]
    allowed = allowed[:200]
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Mine high-signal, reusable atomic Claims from MI-captured evidence.",
            "",
            "Claim definition:",
            "- A Claim is an atomic, reusable argument used to justify decisions/actions.",
            "- Claim types: fact / preference / assumption / goal.",
            "- Temporal semantics are first-class: MI will set asserted_ts; you may set valid_from/valid_to when known (otherwise null).",
            "",
            "Hard constraints:",
            "- Use ONLY the provided segment evidence (derived from MI-captured transcript/evidence).",
            "- Do NOT invent facts or preferences. If unclear, output no claims.",
            "- Each claim MUST cite 1-5 EvidenceLog event_id(s) from the allowed list.",
            "- Each claim MUST have a unique local_id (e.g., c1, c2). Edges MUST reference these local_id values.",
            f"- Output at most the top {int(max_claims)} claims; output fewer when unsure.",
            f"- Only output a claim when confidence >= {min_confidence:.2f}.",
            "- Prefer project-scoped claims unless clearly reusable across projects (then scope=global).",
            "- Avoid duplicating existing canonical preference/goal claims already present in Thought DB context; only output a claim when it adds durable value.",
            "- If you output edges: only connect claims in THIS output (use local_id), and cite source_event_ids from the allowed list.",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- If no high-confidence reusable claims exist, output claims=[] and edges=[].",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "Runtime config (structured):",
            _to_json(runtime_cfg),
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Thought DB context (existing canonical claims; may be empty):",
            _to_json(thought_db_context if isinstance(thought_db_context, dict) else {}),
            "",
            "Segment evidence (compact, most recent last):",
            _to_json(segment_evidence),
            "",
            "Allowed EvidenceLog event_id list (MUST cite only from here):",
            _to_json(allowed),
            "",
            "Thresholds:",
            f"- min_confidence: {min_confidence:.2f}",
            f"- max_claims: {int(max_claims)}",
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output mined claims (or empty lists).",
        ]
    ).strip() + "\n"


def learn_update_prompt(
    *,
    task: str,
    hands_provider: str,
    runtime_cfg: dict[str, Any],
    project_overlay: dict[str, Any],
    recent_learn_suggested: list[dict[str, Any]],
    existing_learned_claims: list[dict[str, Any]],
    allowed_event_ids: list[str],
    allowed_retract_claim_ids: list[str],
    min_confidence: float,
    max_claims: int,
    max_retracts: int,
    notes: str,
) -> str:
    allowed = [str(x) for x in (allowed_event_ids or []) if str(x).strip()][:80]
    retractable = [str(x) for x in (allowed_retract_claim_ids or []) if str(x).strip()][:400]
    return "\n".join(
        [
            "You are MI (Mind Incarnation).",
            "Consolidate preference tightening suggestions into canonical Thought DB updates (append-only).",
            "",
            "Goal:",
            "- Reduce noise and drift: converge multiple per-batch learn_suggested items into a small canonical set.",
            "- Use explicit evolution edges (supersedes/same_as) and/or retractions when appropriate.",
            "",
            "Hard constraints:",
            "- Use ONLY the provided learn_suggested events and existing_learned_claims as input.",
            "- Every NEW claim MUST cite 1-5 EvidenceLog event_id(s) from the allowed list.",
            "- Every edge MUST cite 1-5 EvidenceLog event_id(s) from the allowed list.",
            "- Retractions are append-only: you may retract ONLY claim_ids in allowed_retract_claim_ids, and MUST cite allowed event_ids.",
            "- New learned claims MUST include the tag 'mi:learned'.",
            "- Prefer claim_type=preference or goal; avoid fact/assumption unless truly needed.",
            "- Keep it small: output at most the top few changes. (MI will enforce hard caps.)",
            "",
            "Guidance:",
            "- Prefer 'supersedes' when refining meaning/text; prefer 'same_as' for de-duplication.",
            "- Retract only when the claim is clearly wrong/obsolete/contradicted (high confidence).",
            "",
            "Output rules:",
            "- Output MUST be a single JSON object matching the provided JSON Schema.",
            "- No markdown, no extra keys, no extra commentary.",
            "- patch.claims[*].local_id MUST be unique (e.g., c1, c2).",
            "- patch.edges may reference existing claim_id or a local_id (for new claims).",
            "",
            "User task:",
            task.strip(),
            "",
            f"Hands provider: {hands_provider.strip() or '(unknown)'}",
            "",
            "Runtime config (structured):",
            _to_json(runtime_cfg),
            "",
            "ProjectOverlay:",
            _to_json(project_overlay),
            "",
            "Recent learn_suggested events (this run; compact):",
            _to_json(recent_learn_suggested if isinstance(recent_learn_suggested, list) else []),
            "",
            "Existing learned claims (active canonical; compact):",
            _to_json(existing_learned_claims if isinstance(existing_learned_claims, list) else []),
            "",
            "Allowed EvidenceLog event_id list (MUST cite only from here):",
            _to_json(allowed),
            "",
            "allowed_retract_claim_ids (ONLY retract from this list):",
            _to_json(retractable),
            "",
            "Thresholds (MI will enforce):",
            f"- min_confidence: {float(min_confidence):.2f}",
            f"- max_claims: {int(max_claims)}",
            f"- max_retracts: {int(max_retracts)}",
            "",
            "Run notes:",
            (notes or "").strip(),
            "",
            "Now output the learn_update JSON.",
        ]
    ).strip() + "\n"

