from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any

from ...core.storage import ensure_dir
from ..host_contracts import HostAdapter, HostBinding
from ..host_fs import _ensure_symlink, _safe_unlink


def _single_line(text: str) -> str:
    # Some host formats (e.g., OpenClaw skills frontmatter) expect single-line values.
    return " ".join((text or "").strip().split())


def _openclaw_skill_dirname(workflow_id: str) -> str:
    wid = (workflow_id or "").strip()
    # wf_123_abcd -> mi-wf-123-abcd
    wid = wid.replace("_", "-")
    wid = re.sub(r"[^A-Za-z0-9._-]+", "-", wid).strip("-")
    return f"mi-{wid}" if wid else "mi-workflow"


def _render_openclaw_skill_markdown(*, workflow: dict[str, Any], project_id: str) -> str:
    wid = _single_line(str(workflow.get("id") or ""))
    name = _single_line(str(workflow.get("name") or "")) or wid or "MI workflow"
    trig = workflow.get("trigger") if isinstance(workflow.get("trigger"), dict) else {}
    trig_mode = _single_line(str(trig.get("mode") or "manual"))
    trig_pat = _single_line(str(trig.get("pattern") or ""))
    mermaid = str(workflow.get("mermaid") or "").strip()
    steps = workflow.get("steps") if isinstance(workflow.get("steps"), list) else []

    meta_obj = {
        "mi": {
            "generated": True,
            "host": "openclaw",
            "project_id": project_id,
            "workflow_id": wid,
            "workflow_name": name,
        }
    }
    meta_json = json.dumps(meta_obj, sort_keys=True, separators=(",", ":"))

    lines: list[str] = []
    lines.append("---")
    # OpenClaw parses AgentSkills-compatible SKILL.md folders.
    lines.append(f"name: {_openclaw_skill_dirname(wid)}")
    lines.append(f"description: {_single_line(f'MI workflow: {name}')}")
    # OpenClaw expects metadata to be a single-line JSON string.
    lines.append(f"metadata: '{meta_json}'")
    lines.append("---")
    lines.append("")
    lines.append(f"# {name}")
    lines.append("")
    lines.append("This skill is generated by Mind Incarnation (MI). Do not edit by hand.")
    lines.append("")
    lines.append("## When To Use")
    lines.append("")
    if trig_mode == "task_contains" and trig_pat:
        lines.append(f"- Use when the user task contains: `{trig_pat}`")
    else:
        lines.append("- Use when you want to follow this reusable workflow.")
    lines.append("")
    lines.append("## Notes")
    lines.append("")
    lines.append("- Keep steps coarse-grained; do not force rigid step-by-step reporting.")
    lines.append("- If a step involves network/install/push/publish and it is not clearly safe, ask before doing it.")
    lines.append("")

    if mermaid:
        lines.append("## Flow")
        lines.append("")
        lines.append("```mermaid")
        lines.append(mermaid)
        lines.append("```")
        lines.append("")

    lines.append("## Steps")
    lines.append("")
    if not steps:
        lines.append("(no steps)")
        lines.append("")
    else:
        for i, s in enumerate(steps, start=1):
            if not isinstance(s, dict):
                continue
            sid = _single_line(str(s.get("id") or f"s{i}"))
            kind = _single_line(str(s.get("kind") or ""))
            title = _single_line(str(s.get("title") or "")) or sid or f"step {i}"
            risk_category = _single_line(str(s.get("risk_category") or ""))
            policy = _single_line(str(s.get("policy") or ""))
            notes = str(s.get("notes") or "").strip()
            hands_input = str(s.get("hands_input") or "").strip()
            check_input = str(s.get("check_input") or "").strip()

            lines.append(f"### {i}. {title}")
            if kind:
                lines.append(f"- kind: `{kind}`")
            if risk_category:
                lines.append(f"- risk_category: `{risk_category}`")
            if policy:
                lines.append(f"- policy: `{policy}`")
            if notes:
                lines.append("")
                lines.append(notes)
            if hands_input:
                lines.append("")
                lines.append("Instruction:")
                lines.append("")
                lines.append("```")
                lines.append(hands_input)
                lines.append("```")
            if check_input:
                lines.append("")
                lines.append("Checks:")
                lines.append("")
                lines.append("```")
                lines.append(check_input)
                lines.append("```")
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def _register_openclaw_skills(
    *,
    binding: HostBinding,
    prev_manifest: dict[str, Any],
    gen_root: Path,
    skill_dirnames: list[str],
) -> dict[str, Any]:
    """Register generated OpenClaw skills into the host workspace.

    Strategy:
    - Generate skills under `<generated_root>/skills/<skill_dir>/SKILL.md`.
    - Symlink each skill dir into `<workspace_root>/skills/<skill_dir>`.

    This keeps registration granular and reversible.
    """

    host_skills_root = binding.workspace_root / "skills"
    ensure_dir(host_skills_root)

    prev_links: list[str] = []
    oc = prev_manifest.get("openclaw") if isinstance(prev_manifest.get("openclaw"), dict) else {}
    if isinstance(oc, dict):
        prev_links_raw = oc.get("registered_links") if isinstance(oc.get("registered_links"), list) else []
        for x in prev_links_raw:
            if isinstance(x, str) and x.strip():
                prev_links.append(x.strip())

    # Remove stale links created in the previous run.
    removed: list[str] = []
    keep = {f"skills/{d}" for d in skill_dirnames if d}
    for rel in prev_links:
        rel = rel.strip().lstrip("/")
        if not rel or rel in keep:
            continue
        # Never resolve() here: we want to remove the symlink itself, not its target.
        dst = binding.workspace_root / rel
        try:
            if dst.is_symlink():
                _safe_unlink(dst)
                removed.append(rel)
        except Exception:
            continue

    results: list[dict[str, Any]] = []
    registered: list[str] = []
    for d in skill_dirnames:
        if not d:
            continue
        src = (gen_root / "skills" / d).resolve()
        dst_rel = f"skills/{d}"
        dst = binding.workspace_root / dst_rel
        ok, note = _ensure_symlink(src=src, dst=dst)
        results.append({"dst": dst_rel, "src": f"skills/{d}", "ok": ok, "note": note})
        if ok:
            registered.append(dst_rel)

    return {
        "ok": all(r.get("ok", False) for r in results) if results else True,
        "registered_links": sorted(registered),
        "removed_links": removed,
        "results": results,
    }


class OpenClawSkillsAdapter(HostAdapter):
    """OpenClaw adapter (Skills-only).

    Generates AgentSkills-compatible `SKILL.md` folders and registers each skill dir
    into `<workspace_root>/skills/<skill_dir>` as a symlink (best-effort, reversible).
    """

    def __init__(self) -> None:
        super().__init__("openclaw")

    def generate(self, *, binding: HostBinding, project_id: str, workflows: list[dict[str, Any]]) -> tuple[list[str], dict[str, Any]]:
        gen_root = binding.generated_root
        skills_root = gen_root / "skills"
        ensure_dir(skills_root)

        new_files: list[str] = []
        skill_items: list[dict[str, Any]] = []
        skill_dirnames: list[str] = []

        for w in workflows:
            if not isinstance(w, dict):
                continue
            wid = str(w.get("id") or "").strip()
            if not wid:
                continue
            d = _openclaw_skill_dirname(wid)
            skill_dirnames.append(d)

            skill_md_rel = f"skills/{d}/SKILL.md"
            wf_rel = f"skills/{d}/workflow.json"
            ensure_dir((gen_root / skill_md_rel).parent)
            (gen_root / skill_md_rel).write_text(_render_openclaw_skill_markdown(workflow=w, project_id=project_id), encoding="utf-8")
            (gen_root / wf_rel).write_text(json.dumps(w, indent=2, sort_keys=True) + "\n", encoding="utf-8")
            new_files.extend([skill_md_rel, wf_rel])
            skill_items.append({"dir": d, "workflow_id": wid, "name": str(w.get("name") or ""), "skill_md": skill_md_rel})

        skills_index_rel = "skills/index.json"
        (gen_root / skills_index_rel).write_text(
            json.dumps({"version": "v1", "project_id": project_id, "items": skill_items}, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )
        new_files.append(skills_index_rel)

        ctx = {"skill_dirnames": sorted(set(skill_dirnames))}
        return new_files, ctx

    def register(
        self,
        *,
        binding: HostBinding,
        prev_manifest: dict[str, Any],
        gen_root: Path,
        ctx: dict[str, Any],
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        dirnames = ctx.get("skill_dirnames") if isinstance(ctx.get("skill_dirnames"), list) else []
        skill_dirnames = [str(x) for x in dirnames if isinstance(x, str) and x.strip()]
        res = _register_openclaw_skills(binding=binding, prev_manifest=prev_manifest, gen_root=gen_root, skill_dirnames=skill_dirnames)
        manifest_state = {"registered_links": res.get("registered_links", []) if isinstance(res, dict) else []}
        return res, manifest_state

